# Linux调度算法

## 公平调度CFS

任何进程所获得的处理器时间是由它自己和其他所有可运行进程nice值得相对差值决定的

# Linux调度的实现

https://zhuanlan.zhihu.com/p/363668741关于调度器的知乎讲解，看完书回来看一遍理一下

CFS四个主要组成部分

- 时间记账
- 进程选择
- 调度器入口
- 睡眠和唤醒

## 时间记账

### 调度器实体结构

嵌入在`strcut task_struct`内，名为`se`。用于追踪进程记账

### 虚拟实时

虚拟运行时间`vruntime`是花在运行上的时间和，即线程在处理器上花费的时间。vruntime是按线程的。

`vruntime`变量存放标准化（被nice等加权的）虚拟运行时间，以ns为单位，和节拍器不相关。

虚拟运行时是真实运行时间除以权重, 权重越大虚拟运行时**增长越慢**, 于是就能运行更久. 当然, 对于一般的任务而言, 这段虚拟运行时就等于真实运行时间. (权重等于默认值)

通过`update_curr()`计算当前进程得执行时间，并将其存放在变量`delta_exec`中。然后又将运行时间传递给`__update_curr()`，由后者再根据当前可运行进程总数对运行时间进行加权计算。最终将上述的权重值与当前运行进程的`vruntime`相加。

`update_curr()`会在多个地方使用（挂上红黑树和从红黑树上摘除时都会使用）

### 进程选择

当CFS需要选择下一个运行进程时，它会挑一个具有最小`vruntime`的进程

需要区分三个可能出现的变量

```c
cfs_rq->curr ;//应该是当前正在执行的进程
cfs_rq->rb_leftmost;//就绪队列中最左边的节点，不是当前正在执行的进程，而是下一个要执行的进程
```



#### 挑选下一个任务

CFS使用**红黑树**来组织**可运行进程队列**，寻找最小`vruntime`值得进程，挑选的过程函数为`__pick_next_entity()`。实际上是通过该函数调用存储的`cfs_rq->rb_leftmost`。直接存储最左节点更简单，如果`rb_leftmost==NULL`说明**没有可运行进程**

#### 向树中加入进程

发生在进程变为**可运行状态（被唤醒）**或者是通过`fork()`调用第一次创建进程时。通过`enqueue_entity()`函数实现，该函数会更新“当前任务”的运行时统计数据

用一个while()循环找到合适的位置，如果是新的最左节点，则要更新最左节点。否则，退出循环后（`*link==NULL`），在父节点上调用`rb_link_node()`插入新节点，然后调用`rb_insert_color()`更新树的平衡性（旋转，着色等）。

#### 向树中删除进程

删除动作发生再进程堵塞（变为不可运行态）或者终止时（结束运行）

只有要删除的进程不是当前正在运行的进程时才能执行删除操作。（因此如果要删除正在执行的进程，只能等他运行结束，在运行下一个进程之前执行删除？）

如果删除的是`cfs_rq->rb_leftmost`，则需要更新这个最左节点。然后由`rb_erase()`函数删除。

### 调度器入口

`schedule()`函数，通常需要和一个具体的调度类相关联，他会找到一个最高优先级的调度类，该调度类需要有自己的可运行队列，然后问他谁是下一个该运行的进程。

这个函数主要调用`pick_next_task()`函数，该函数会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最高优先级的进程。

开始时有个优化，如果所有可运行进程的数量等于CFS中可运行的数量，则自动选择CFS作为调度类。否则选择优先级最高且有可运行队列进程的调度类。`sched_class_highest`代表优先级最高的调度类

### 休眠和唤醒

休眠操作：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用`schedule()`选择和执行一个其他进程。

唤醒操作：进程被设置为可执行状态，然后再从等待队列中移到可执行红黑树中。

#### 等待队列

等待队列是由等待某些事件发生的进程组成的**简单链表**

休眠的推荐操作：

```c
//'q'是希望休眠的等待队列
DEFINE_WAIT(wait);//创建一个等待队列的项

add_wait_queue(q,&wait);
while(!condition){//`condition`是在等待的事件
    prepare_to_wait(&q,&wait,TASK_INTERRUPTIBLE);//伪唤醒，不是因为等待事件达成而唤醒的，后面需要在下一次循环前判断是否能被唤醒
    if(signal_pending(current))
        //处理信号
    schedule();
}//循环结束需要判断是否等待事件完成，如果没有则重新循环，进入休眠
finish_wait(&q,&wait);//循环结束，结束休眠，移出等待队列
```

#### 唤醒

通过`wake_up()`进行，它会唤醒指定的等待队列上的所有进程。

它调用`try_to_wake_up()`，该函数负责将进程设置为`TASK_RUNNING`状态，调用`enqueue_task()`将此进程放入红黑树中，如果被唤醒的进程优先级比当前正在执行的进程的优先级高，还要设置`need_resched`标志。

通常哪段代码促使等待条件达成，它就要负责随后调用`wake_up`函数。

# 抢占和上下文切换

上下文切换，也就是从一个可执行进程切换到另一个可执行进程，有`context_switch()`函数负责处理。每当一个新的进程被选出来准备投入运行的时候，`schedule()`就会调用该函数。它完成两项基本工作：

- 调用`switch_mm()`，把**虚拟内存**从上一个进程切换到新进程中
- 调用`switch_to()`，从上一个进程的处理器状态切换到新进程的处理器状态。包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。

内核提供一个`need_resched`标志来表明是否需要重新执行一次调度。

- 当某进程应该被抢占时，`scheduler_tick()`会设置这个标志
- 当一个优先级高的进程进入可执行状态的时候，`try_to_wake_up()`也会设置这个标志。

在**返回用户空间**以及**从中断返回**的时候，内核也会检查`need_resched`标志。如果已被设置，内核会在继续执行之前调用调度程序

每个进程都包含一个`need_resched`标志，这是因为访问进程描述符内的数值要比访问一个全局变量快（因为`current宏`速度很快并且描述符通常都在高速缓存中）。在2.6版中，它被移到`thread_info`结构体里，用一个特别的标志变量中的一位来表示

## 用户抢占

内核在即将返回用户空间的时候，如果`need_resched`标志被设置，会导致`schedule()`被调用，此时就会发生用户抢占，返回时就可以选择一个新的进程去执行。

用户抢占在以下情况时产生：

- 从系统调用返回用户空间时。
- 从中断处理程序返回用户空间时。

## 内核抢占

由于内核支持SMP（多处理），如果当前内核级进程没有持有锁，则正在执行的代码就是可重新导入的，则重新调度是安全的，此时可以抢占。

每个进程的`thread_info`引入`preempt_count`计数器。该计数器初始值为0，每当使用锁的时候数值加1，释放锁的时候数值减1。当数值为0的时候，内核就可执行抢占。

从中断返回内核空间的时候，如果`need_resched`标志被设置且`preempt_count`为0，则调度程序会被调用。

如果当前进程持有的所有的锁都被释放了，`preempt_count`就会重新为0。此时，**释放锁的代码**会检查`need_resched`是否被设置。如果是的话，就会调用调度程序。

如果内核中的进程被阻塞了，或者显示地调用了`schedule()`，内核抢占也会显式地发生。

内核抢占会发生在：

- 中断处理程序正在执行，且返回内核空间之前。
- 内核代码再一次具有可抢占性地时候（所有锁释放）。
- 如果内核中的任务显式地调用`schedule()`。
- 如果内核中的任务阻塞（这同样也会导致调用`schedule()`）。

# 实时调度策略

Linux提供了两种实时调度策略：`SCHED_FIFO`和`SCHED_RR`。普通的、非实时策略是`SCHED_NORMAL`。

`SCHED_FIFO`不适用时间片，先入先出。处于可运行状态的`SCHED_FIFO`比任何`SCHED_NORMAL`都先得到调度。一旦`SCHED_FIFO`处于可执行状态，就会一直执行，知道它自己受阻塞或者显式地释放处理器为止；它不基于时间片，可以一直执行下去。只有更高优先级地`SCHED_FIFO`或者`SCHED_RR`任务才能抢占。

`SCHED_RR`和`SCHED_FIFO`基本相同，只是带有了时间片。也就是说`SCHED_RR`是带有时间片的`SCHED_FIFO`。时间片只用来重新调度同一优先级的进程。

对于`SCHED_FIFO`级进程，高优先级总是立即抢占低优先级，但低优先级进程决不能抢占`SCHED_RR`，即使它的时间片耗尽

Linux实时调度算法提供一种**软实时**工作方式：内核调度进程，**尽力**使进程在它的限定时间到来前运行，但内核不保证总能满足这些进程的要求。

实时优先级范围从`0`到`MAX_RT_PRIO-1`。默认情况`MAX_RT_PRIO`为`100`，也就是`0-99`。`SCHED_NORMAL`的`nice`值对应`MAX_RT_PRIO`到`MAX_RT_PRIO+40`。也就是`-20~+19`对应`100~139`

# 与调度相关的系统调用

