# 虚函数的实现机制

虚函数表相关知识点：

- 虚函数表存放的内容：类的虚函数的地址。
- 虚函数表建立的时间：编译阶段，即程序的编译过程中会将虚函数的地址放在虚函数表中。
- 虚表指针保存的位置：虚表指针存放在对象的内存空间中最前面的位置，这是为了保证正确取到虚函数的偏移量。

注：虚函数表和类绑定，虚表指针和对象绑定。即类的不同的对象的虚函数表是一样的，但是每个对象都有自己的虚表指针，来指向类的虚函数表。



派生类对象内存：虚函数表>基类成员>派生类成员

# 类的静态成员与非静态成员

## 数据成员：

静态数据成员是类的一部分，为类的所有实例共享(静态区)；非静态数据成员，类的每个实例都有一份拷贝(动态区)。

静态数据成员的访问：

静态数据成员是类的一部分，在产生任何实例之前已经存在，通过类名::静态成员变量名访问。

## 函数成员(都在代码区)：

静态函数成员与非静态函数成员都为类所有，对象并不存在函数的拷贝。静态成员函数和非静态成员函数的根本区别在于非静态函数由对象名.或者对象指针->调用，调用时编译器会向函数传递this指针；静态成员函数则有类名::或者对象名.调用，编译器不向函数传递this指针，不识别对象个体，经常用来操作类的静态数据成员，**要访问类的非静态成员可以通过对象来实现**。

## 内存角度分析：

类的**静态成员**(数据成员和函数成员)为类本身所有，在**类加载的时候**就会分配内存，可以通过类名直接访问；**非静态成员**(数据成员和函数成员)属于类的实例所有，所以只有在**创建类的实例**的时候才会分配内存，并通过实例去访问。

> 注意：类的静态数据成员是静态存储，它是静态生存周期，必须进行初始化。
>
> 注意：静态数据成员的初始化在类体外进行，前面不加static以免与一般静态变量或者对象混淆。

## 静态成员函数访问非静态成员报错：

类的静态成员在类加载的时候就已经分配内存，而此时类的非静态成员尚未分配内存，访问内存中不存在的东西自然会出错。

> 指的是直接调用类内的非静态成员对象。但可以通过传入参数的方式调用，比如

```c++
void Test::smf(Test tt)
{
	cout << "tt.A : " << tt.A << endl;    //静态成员函数中通过对象来引用非静态成员
	//不能直接cout<<A<
	cout << "Test::B : " << Test::B << endl;
	cout << "tt.B : " << tt.B << endl;
}
 
```

## C++ 中析构函数为什么要求是虚的

这是因为，通过基类指针来销毁派生类对象这个行为，当基类没有虚析构函数时会产生问题。我们知道删除指针对象是没有问题的，指针对象的析构函数会正确调用，但仅限于指针的类型所表示的对象大小。如果以一个基类指针指向其派生类，删除这个基类指针只能删除基类对象部分，而不能删除整个派生类对象，原因是通过基类指针无法访问派生类的析构函数。
但是，如果像其它虚函数一样，基类的析构函数也是虚的，那么派生类的析构函数也必然是虚的，删除基类指针时，它就会通过虚函数表找到正确的派生类析构函数并调用它，从而正确析构整个派生类对象。

# 虚继承

虚继承和普通继承时对象内存中所存数据顺序不同

普通继承先是父类变量然后才是子类变量

虚继承则是先子类变量，然后才是父类变量

关于虚继承虚类等所有内存状态如下链接

https://blog.csdn.net/bailang_zhizun/article/details/117124494



https://blog.csdn.net/haoel/article/details/3081328

https://blog.csdn.net/castle_kao/article/details/71024411

# 【c++内存分布系列】虚基类表

　　虚基类表相对于虚函数表要稍微难理解些，故单独提出来。　　虚函数表是在对象生成时插入一个虚函数指针，指向虚函数表，这个表中所列就是虚函数。![img](https://images0.cnblogs.com/blog/560193/201309/06163455-d34a45a0399e4106a63ec32e751627f6.png)　　虚基类表原理与虚函数表类似，不过虚基类表的内容有所不同。表的第一项表示派生类对象指针相对于虚基类表指针的偏移，从第二项开始表示各个基类地址相对于虚基类表指针的偏移。![img](https://images0.cnblogs.com/blog/560193/201309/06165032-67927005c9424aad955dadb5edad4158.png)

## 关键字

